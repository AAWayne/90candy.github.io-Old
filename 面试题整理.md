**1、以下代码存在什么问题？**

```
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"1");
    
    dispatch_sync(dispatch_get_main_queue(), ^{
        
        NSLog(@"2");
    });
    
    NSLog(@"3");
    
}
```
只输出：1 。发生主线程锁死。这是为什么呢？

```
因为dispatch_get_main_queue()得到的是一个串行队列，串行队列的特点： 一次只调度一个任务，队列中的任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）

sync为同步操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行

dispatch_sync提交一个 打印任务2 到主线程关联的串行队列中，主线程关联的串行队列现在有一个viewDidLoad任务，打印任务2 排在viewDidLoad后面，

队列FIFO（先进先出）的原则，打印任务2 想要得到执行必须等到viewDidLoad执行完毕后才能得到执行，但是viewDidLoad想要执行完毕必须要等 打印任务2 执行完毕，所以就卡死在这了。

```

 **2、用@property声明的NSString（或NSArray，NSDictionary）一般用copy修饰，为什么？如果改用strong关键字，可能造成什么问题？**

```
a. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.

b. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.
```

举例说明：定义一个以 strong 修饰的 array：

```
@property (nonatomic , strong) NSArray *array;
```

然后进行下面的操作：

```
NSArray *array = @[ @1, @2, @3, @4 ];
NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
   
self.array = mutableArray;
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);
   
[mutableArray addObjectsFromArray:array];
self.array = [mutableArray copy];
[mutableArray removeAllObjects];;
NSLog(@"%@",self.array);
```
打印结果如下所示：

```
2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (
)
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (
   1,
   2,
   3,
   4
)
```
 
**3、类方法和实例方法有什么本质区别和联系？**

类方法：

```
类方法是属于类对象的
类方法只能通过类对象调用
类方法中的self是类对象
类方法可以调用其他的类方法
类方法中不能访问成员变量
类方法中不能直接调用对象方法
```

实例方法：

```
实例方法是属于实例对象的
实例方法只能通过实例对象调用
实例方法中的self是实例对象
实例方法中可以访问成员变量
实例方法中直接调用实例方法
实例方法中也可以调用类方法(通过类名)
```

**4、在block内如何修改block外部变量？**

```
__block int a = 0;
NSLog(@"定义前：%p", &a);         //栈区
void (^foo)(void) = ^{
   a = 1;
   NSLog(@"block内部：%p", &a);    //堆区
};
NSLog(@"定义后：%p", &a);         //堆区
foo();
```
打印结果：

```
定义前：0x16fda86f8
定义后：0x155b22fc8
block内部： 0x155b22fc8
```

**5、如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）**
 
使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
	// 合并图片
});
```

**6、**
**7、**
**8、**
